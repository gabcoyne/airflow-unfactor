---
phase: 01-p1-knowledge-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - colin/models/operators/kubernetes.md
  - colin/models/operators/http.md
  - colin/models/operators/sftp.md
autonomous: true
requirements: [KNOW-01, KNOW-05, KNOW-06]

must_haves:
  truths:
    - "kubernetes.md contains KubernetesPodOperator section with Kubernetes work pool architectural shift guidance"
    - "http.md contains SimpleHttpOperator section with httpx pattern and explicit 'no prefect-http package' warning"
    - "sftp.md contains SSHOperator section with paramiko/fabric pattern and Secret block credential guidance"
  artifacts:
    - path: "colin/models/operators/kubernetes.md"
      provides: "KubernetesPodOperator → Kubernetes work pool translation knowledge"
      contains: "KubernetesPodOperator"
    - path: "colin/models/operators/http.md"
      provides: "SimpleHttpOperator → httpx task translation knowledge"
      contains: "SimpleHttpOperator"
    - path: "colin/models/operators/sftp.md"
      provides: "SSHOperator → paramiko/fabric task translation knowledge"
      contains: "SSHOperator"
  key_links:
    - from: "colin/models/operators/kubernetes.md"
      to: "colin run compilation"
      via: "{% section %} format parsed by Colin"
      pattern: "{% section KubernetesPodOperator %}"
    - from: "colin/models/operators/http.md"
      to: "colin run compilation"
      via: "{% section %} format parsed by Colin"
      pattern: "{% section SimpleHttpOperator %}"
    - from: "colin/models/operators/sftp.md"
      to: "colin run compilation"
      via: "{% section %} format parsed by Colin"
      pattern: "{% section SSHOperator %}"
---

<objective>
Author three Colin model files for the infrastructure, HTTP, and SSH operator families: kubernetes.md (KNOW-01), http.md (KNOW-05), and sftp.md (KNOW-06).

Purpose: These three operator families represent distinct translation patterns — architectural shift (Kubernetes), no-package inline library (HTTP, SSH) — and are the most likely to cause LLM regression without explicit guidance.

Output: Three new `.md` files in `colin/models/operators/` following the established `{% section %}` + field format used by existing model files.
</objective>

<execution_context>
@/Users/gcoyne/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gcoyne/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-p1-knowledge-expansion/01-RESEARCH.md
@colin/models/operators/aws.md
@colin/models/operators/core.md

<interfaces>
<!-- Colin model file format — every section MUST have these fields in this order -->
<!-- Extracted from colin/models/operators/aws.md (canonical reference) -->

YAML frontmatter:
```yaml
---
name: {Provider Name} Operator Mappings
colin:
  output:
    format: json
---
```

Section structure:
```
{% section OperatorName %}
## operator
## module
## source_context
## prefect_pattern
## prefect_package
## prefect_import
## example
### before
### after
## notes
{% endsection %}
```

JSON output schema (from operators-core.json):
```json
{
  "OperatorName": {
    "operator": "string",
    "module": "string",
    "source_context": "string",
    "prefect_pattern": "string",
    "prefect_package": "string",
    "prefect_import": "string",
    "example": { "before": "string", "after": "string" },
    "notes": ["string"],
    "related_concepts": ["string"]
  }
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Author kubernetes.md — KubernetesPodOperator Colin model</name>
  <files>colin/models/operators/kubernetes.md</files>
  <action>
Create `colin/models/operators/kubernetes.md` with YAML frontmatter (`name: Kubernetes Provider Operator Mappings`) and one `{% section KubernetesPodOperator %}` block.

This is an ARCHITECTURAL SHIFT entry, not a parameter-for-parameter mapping. Key content:

- `operator`: KubernetesPodOperator
- `module`: airflow.providers.cncf.kubernetes.operators.pod
- `source_context`: Describe that it spawns a Kubernetes pod per task execution, running a container image with specified resources, env vars, and commands. Uses the kubernetes Python SDK internally.
- `prefect_pattern`: Kubernetes work pool with base job template — infrastructure is declared at the work pool level, not per-task
- `prefect_package`: prefect-kubernetes
- `prefect_import`: from prefect import flow, task (infrastructure is in work pool config, not code imports)
- `example.before`: KubernetesPodOperator with image, namespace, env_vars, container_resources, cmds/arguments (use the example from 01-RESEARCH.md)
- `example.after`: A @flow deployed to a Kubernetes work pool — the flow contains business logic, infrastructure is in the work pool config. Include comments explaining: (1) create Kubernetes work pool via UI/CLI, (2) deploy flow targeting that pool, (3) set image/env/resources in base job template
- `notes`: CRITICAL items:
  - KubernetesPodOperator is an INFRASTRUCTURE concern, not a task concern in Prefect
  - No per-task pod spawning in Prefect; infrastructure at work pool level
  - `image` → set in Kubernetes work pool base job template
  - `env_vars` → environment variables in work pool or KubernetesJob block
  - `container_resources` → customized via base job template
  - `cmds`, `arguments` → override container command in job template
  - Do NOT use subprocess.run() or docker SDK to emulate KubernetesPodOperator
  - Do NOT use kubernetes Python SDK (kubernetes.client) directly
  - For per-task image isolation: deploy each flow/subflow to separate Kubernetes work pool
- `related_concepts`: ["infrastructure-as-work-pool", "deployment-patterns"]

Follow the exact field order and markdown formatting from aws.md. Use ```python fenced code blocks in examples.
  </action>
  <verify>
    <automated>grep -c "{% section KubernetesPodOperator %}" colin/models/operators/kubernetes.md && grep -c "{% endsection %}" colin/models/operators/kubernetes.md && grep -q "prefect-kubernetes" colin/models/operators/kubernetes.md && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>kubernetes.md exists with KubernetesPodOperator section containing architectural shift guidance, Kubernetes work pool pattern, and explicit anti-patterns (no subprocess, no kubernetes SDK)</done>
</task>

<task type="auto">
  <name>Task 2: Author http.md — SimpleHttpOperator Colin model</name>
  <files>colin/models/operators/http.md</files>
  <action>
Create `colin/models/operators/http.md` with YAML frontmatter (`name: HTTP Provider Operator Mappings`) and two sections: `{% section SimpleHttpOperator %}` and `{% section HttpOperator %}`.

Both are NO-PACKAGE translations. Key content for SimpleHttpOperator:

- `operator`: SimpleHttpOperator
- `module`: airflow.providers.http.operators.http
- `source_context`: Calls an HTTP endpoint. Uses `requests` library internally, takes http_conn_id for base URL and auth, supports response_check callable and log_response.
- `prefect_pattern`: httpx (or requests) inside @task — no dedicated Prefect HTTP package
- `prefect_package`: none (use httpx directly)
- `prefect_import`: import httpx
- `example.before`: SimpleHttpOperator with http_conn_id, endpoint, method, data, headers, response_check, log_response (use example from RESEARCH.md)
- `example.after`: @task using httpx.post with Secret.load for base URL, get_run_logger for logging, raise_for_status for response check (use example from RESEARCH.md)
- `notes`:
  - There is NO prefect-http package; use httpx or requests directly inside @task
  - http_conn_id → store base URL and credentials in a Secret block or environment variable
  - response_check callable → implement as conditional assertion inside @task body
  - log_response=True → use get_run_logger() to log response content
  - httpx is preferred over requests for new Prefect code (async support)
  - Use @task(retries=N) for retry behavior instead of custom retry loops
- `related_concepts`: ["connection-to-secret-block", "no-package-pattern"]

HttpOperator section: identical pattern to SimpleHttpOperator (HttpOperator is the newer name in Airflow 2.x for the same class). Keep it brief — reference SimpleHttpOperator in notes.
  </action>
  <verify>
    <automated>grep -c "{% section SimpleHttpOperator %}" colin/models/operators/http.md && grep -c "{% section HttpOperator %}" colin/models/operators/http.md && grep -q "NO prefect-http" colin/models/operators/http.md && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>http.md exists with SimpleHttpOperator and HttpOperator sections, explicit "no prefect-http package" warning, httpx pattern with Secret block credential migration</done>
</task>

<task type="auto">
  <name>Task 3: Author sftp.md — SSHOperator Colin model</name>
  <files>colin/models/operators/sftp.md</files>
  <action>
Create `colin/models/operators/sftp.md` with YAML frontmatter (`name: SSH Provider Operator Mappings`) and one `{% section SSHOperator %}` block.

This is a NO-PACKAGE translation. Key content:

- `operator`: SSHOperator
- `module`: airflow.providers.ssh.operators.ssh
- `source_context`: Executes a command on a remote host via SSH. Uses paramiko internally, takes ssh_conn_id for host, username, and key/password.
- `prefect_pattern`: paramiko.SSHClient or fabric.Connection inside @task with Secret block for credentials
- `prefect_package`: none (use paramiko or fabric directly)
- `prefect_import`: import paramiko
- `example.before`: SSHOperator with ssh_conn_id and command (use example from RESEARCH.md)
- `example.after`: @task using paramiko.SSHClient with Secret.load for private key, proper connect/exec_command/close pattern (use example from RESEARCH.md)
- `notes`:
  - There is NO prefect-ssh package; use paramiko or fabric directly inside @task
  - ssh_conn_id → create a Secret block named "ssh-private-key" with private key content, or separate blocks for host/username/key
  - Before running: user must create Secret block(s) for SSH credentials
  - paramiko is the baseline recommendation (stable API); fabric is a higher-level option
  - Use get_run_logger() to log command output
  - Handle exit status checking — raise on non-zero exit
  - For password auth: use Secret block for password instead of key
- `related_concepts`: ["connection-to-secret-block", "no-package-pattern"]

Follow the exact field order and markdown formatting from aws.md.
  </action>
  <verify>
    <automated>grep -c "{% section SSHOperator %}" colin/models/operators/sftp.md && grep -c "{% endsection %}" colin/models/operators/sftp.md && grep -q "paramiko" colin/models/operators/sftp.md && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>sftp.md exists with SSHOperator section containing paramiko/fabric pattern, Secret block credential guidance, and explicit "no prefect-ssh package" warning</done>
</task>

</tasks>

<verification>
All three files exist in `colin/models/operators/` with valid `{% section %}` blocks:
```bash
for f in kubernetes.md http.md sftp.md; do
  echo "=== $f ===" && grep "{% section" colin/models/operators/$f && grep "{% endsection" colin/models/operators/$f
done
```
</verification>

<success_criteria>
1. `colin/models/operators/kubernetes.md` has KubernetesPodOperator section with architectural shift notes
2. `colin/models/operators/http.md` has SimpleHttpOperator and HttpOperator sections with "no prefect-http" warning
3. `colin/models/operators/sftp.md` has SSHOperator section with paramiko pattern and Secret block guidance
4. All files follow the exact `{% section %}` format with all required fields (operator, module, source_context, prefect_pattern, prefect_package, prefect_import, example, notes)
</success_criteria>

<output>
After completion, create `.planning/phases/01-p1-knowledge-expansion/01-01-SUMMARY.md`
</output>

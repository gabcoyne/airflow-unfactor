---
phase: 03-p2-knowledge-expansion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - colin/models/patterns.md
  - colin/models/concepts.md
  - src/airflow_unfactor/knowledge.py
  - src/airflow_unfactor/tools/scaffold.py
  - tests/test_scaffold.py
autonomous: true
requirements:
  - KNOW-09
  - KNOW-10
  - KNOW-11
  - KNOW-12

must_haves:
  truths:
    - "lookup_concept('macros.ds_add') returns a Jinja macro translation entry with Python datetime equivalent"
    - "lookup_concept('dag_run.conf') returns a flow parameters mapping"
    - "lookup_concept('depends_on_past') returns an entry with equivalent: none and a workaround section"
    - "lookup_concept('deferrable') returns an entry explaining Prefect alternatives for resource-efficient waiting"
    - "scaffold_project with schedule_interval='0 6 * * *' generates prefect.yaml with cron schedule under deployments"
    - "scaffold_project with schedule_interval=None omits the schedules section entirely"
  artifacts:
    - path: "colin/models/patterns.md"
      provides: "Expanded Jinja template variable translations"
      contains: "jinja-template-variables"
    - path: "colin/models/concepts.md"
      provides: "depends_on_past and deferrable operator concept entries"
      contains: "depends-on-past"
    - path: "src/airflow_unfactor/tools/scaffold.py"
      provides: "Schedule-aware scaffold_project with schedule_interval parameter"
      contains: "schedule_interval"
    - path: "src/airflow_unfactor/knowledge.py"
      provides: "Query normalization for Jinja syntax"
      contains: "normalize_query"
    - path: "tests/test_scaffold.py"
      provides: "Tests for schedule translation in scaffold"
      contains: "schedule"
  key_links:
    - from: "src/airflow_unfactor/knowledge.py"
      to: "colin/models/patterns.md"
      via: "lookup() finds Jinja macro entries compiled from patterns.md"
      pattern: "jinja"
    - from: "src/airflow_unfactor/tools/scaffold.py"
      to: "prefect.yaml output"
      via: "_schedule_yaml generates schedule config"
      pattern: "schedule"
---

<objective>
Expand Jinja macro translations in patterns.md, add depends_on_past and deferrable operator concept entries to concepts.md, add query normalization for Jinja syntax in knowledge.py, and make the scaffold tool schedule-aware.

Purpose: Users migrating DAGs with Jinja templates, depends_on_past, deferrable operators, and cron schedules get intent-first guidance. The scaffold tool generates real schedule config instead of placeholders.
Output: Expanded patterns.md, expanded concepts.md, updated knowledge.py with query normalization, schedule-aware scaffold.py with tests.
</objective>

<execution_context>
@/Users/gcoyne/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gcoyne/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-p2-knowledge-expansion/03-RESEARCH.md

@colin/models/patterns.md (existing jinja-ds-to-runtime and jinja-params-to-flow-params — expand, don't duplicate)
@colin/models/concepts.md (add depends_on_past and deferrable entries)
@src/airflow_unfactor/knowledge.py (add query normalization)
@src/airflow_unfactor/tools/scaffold.py (add schedule_interval parameter)
@tests/test_scaffold.py (add schedule tests)
</context>

<interfaces>
<!-- From existing knowledge.py -->
```python
def lookup(concept: str, knowledge: dict[str, Any]) -> dict[str, Any]:
    # Tries exact match, case-insensitive, then substring
    # Falls back to FALLBACK_KNOWLEDGE
    # Returns {"status": "found", ...} or {"status": "not_found", "suggestions": [...]}
```

<!-- From existing scaffold.py -->
```python
async def scaffold_project(
    output_directory: str,
    project_name: str | None = None,
    include_docker: bool = True,
    include_github_actions: bool = True,
) -> str:
```

<!-- Colin concept entry format (from existing concepts.md) -->
```
{% section concept-id %}
## id
## airflow (### name, ### description, ### module)
## prefect (### name, ### description, ### package, ### import_statement)
## rules
## example (### before / ### after)
{% endsection %}
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Expand Jinja macros in patterns.md and add concept entries to concepts.md</name>
  <files>colin/models/patterns.md, colin/models/concepts.md</files>
  <action>
**Part A: Add Jinja template variables section to patterns.md**

Add a new `{% section jinja-template-variables %}` to `colin/models/patterns.md` (AFTER the existing sections, not replacing them). This section consolidates all Jinja macro translations. The existing `jinja-ds-to-runtime` and `jinja-params-to-flow-params` sections remain unchanged (they are already compiled to JSON); this new section is the comprehensive reference.

Required macros (from KNOW-09):
- `{{ ds }}` → `runtime.flow_run.scheduled_start_time.strftime("%Y-%m-%d")`
- `{{ ts }}` → `runtime.flow_run.scheduled_start_time.isoformat()`
- `{{ execution_date }}` → `runtime.flow_run.scheduled_start_time`
- `{{ next_ds }}` → compute from scheduled_start_time + interval (PARADIGM SHIFT: interval comes from deployment, not flow)
- `{{ prev_ds }}` → compute from scheduled_start_time - interval (PARADIGM SHIFT: explain why this concept doesn't map directly)
- `{{ run_id }}` → `runtime.flow_run.name` or `str(runtime.flow_run.id)`
- `{{ dag_run.conf }}` → flow function parameters (typed)
- `{{ macros.ds_add(ds, N) }}` → `(date + timedelta(days=N)).strftime("%Y-%m-%d")`
- `{{ params.x }}` → flow function parameter `x`
- `{{ var.value.x }}` → `Variable.get("x")` from `prefect.variables`

Extra common macros (Claude's discretion from CONTEXT.md):
- `{{ ds_nodash }}` → `runtime.flow_run.scheduled_start_time.strftime("%Y%m%d")`
- `{{ macros.ds_format(ds, input_format, output_format) }}` → `datetime.strptime(...).strftime(output_format)`
- `{{ macros.datetime }}` → `from datetime import datetime`
- `{{ macros.timedelta }}` → `from datetime import timedelta`
- `{{ task_instance.task_id }}` → `runtime.task_run.task_name` (within @task)

Structure the section with:
- `## id`: `jinja-template-variables`
- `## airflow_pattern`: Jinja2 template variables rendered by Airflow's template engine at task execution time
- `## prefect_pattern`: Pure Python via `prefect.runtime` module, flow parameters, and `prefect.variables`
- `## rules`: One rule per macro mapping. For `prev_ds` and `next_ds`, include PARADIGM SHIFT explanation: "Prefect flows don't own their schedule — the deployment does. If the interval matters, pass it as a flow parameter."
- `## example`: Show a comprehensive before/after with 4-5 macros in a single task

Intent-first per CONTEXT.md: explain WHAT each macro achieves before HOW to replace it. For macros with no direct equivalent (prev_ds, next_ds), explain the paradigm shift — why the concept doesn't map, not just that it doesn't.

**Part B: Add depends_on_past entry to concepts.md**

Add a new `{% section depends-on-past %}` to concepts.md:
- `## id`: `depends-on-past`
- `## airflow` → `### name`: depends_on_past, `### description`: "Prevents a task from running if its previous DAG run instance failed. Enforces sequential data integrity across scheduled runs.", `### module`: airflow.models.dag
- `## prefect` → `### name`: No direct equivalent, `### description`: "Prefect flows are stateless by default — each run is independent. No built-in mechanism to check previous run state before proceeding."
- `### equivalent`: none
- `### workaround`: Query Prefect API for previous flow run state at flow start. Show the code pattern from RESEARCH.md Pattern 5 (get_client, read_flow_runs, check state).
- `## rules`: "There is no drop-in replacement. If data integrity requires sequential success, query the Prefect API. This is an explicit choice — most Prefect flows benefit from independent runs."
- Intent-first: "This Airflow concept achieves sequential data integrity — each run depends on the previous one completing successfully. In Prefect, this paradigm doesn't exist because flows are designed to be independent. The workaround is to explicitly query for the previous run's state."

Tone per CONTEXT.md: "Honest and opinionated — No direct equivalent. Here's what we recommend instead..."

**Part C: Add deferrable operator entry to concepts.md**

Add a new `{% section deferrable-operators %}` to concepts.md:
- `## id`: `deferrable-operators`
- `## airflow` → `### name`: Deferrable Operators / Async Sensors, `### description`: "A deferrable operator suspends itself and frees the worker slot while waiting for an external event, handing off to a Trigger component. Avoids wasting worker resources on long-running waits."
- `## prefect` → `### name`: No direct equivalent
- `### equivalent`: none
- `### workaround`: Three patterns based on wait duration:
  1. Short waits (< 5 min): `@task(retries=N, retry_delay_seconds=M)` — worker holds slot but retries on failure
  2. Long waits (reschedule-mode equivalent): Prefect Automations — emit event when condition is met, trigger flow from event
  3. Polling loops: `@task` with explicit loop + `time.sleep()` (same overhead as Airflow poke mode)
- `## rules`: From RESEARCH.md Pattern 6. Be honest: "Prefect 3.x does not have Airflow-style deferrable operators."
- Intent-first: "This Airflow concept achieves resource efficiency during long waits — the worker is freed while a lightweight Trigger polls. In Prefect, this paradigm doesn't exist because there is no Triggerer component. If resource efficiency during long waits is critical, use Automations + event-driven deployment triggers."

Both concept entries must use `equivalent: none` with `workaround` section per CONTEXT.md locked decision.
  </action>
  <verify>
    <automated>grep -q "jinja-template-variables" colin/models/patterns.md && grep -q "macros.ds_add" colin/models/patterns.md && grep -q "var.value" colin/models/patterns.md && grep -q "depends-on-past" colin/models/concepts.md && grep -q "equivalent: none" colin/models/concepts.md && grep -q "deferrable-operators" colin/models/concepts.md && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>patterns.md has jinja-template-variables section covering all 10+ macros with paradigm shift explanations; concepts.md has depends-on-past and deferrable-operators entries both with equivalent: none and workaround sections</done>
</task>

<task type="auto">
  <name>Task 2: Add query normalization to knowledge.py and schedule translation to scaffold.py</name>
  <files>src/airflow_unfactor/knowledge.py, src/airflow_unfactor/tools/scaffold.py, tests/test_scaffold.py</files>
  <action>
**Part A: Add query normalization to knowledge.py**

Add a `normalize_query(query: str) -> str` function in `knowledge.py` that strips common Jinja wrappers before lookup. Call it at the top of the `lookup()` function.

Normalization rules:
1. Strip `{{ }}` wrapping: `{{ macros.ds_add(ds, 5) }}` → `macros.ds_add(ds, 5)`
2. Strip leading `macros.` prefix: `macros.ds_add` → `ds_add` (but keep original as fallback)
3. Strip leading `var.value.` prefix: `var.value.my_key` → treat as Variable lookup
4. Strip leading/trailing whitespace

Implementation:
```python
import re

def normalize_query(query: str) -> str:
    """Normalize Jinja-style queries for lookup.

    Strips {{ }}, macros., and var.value. prefixes so that
    lookup_concept("{{ macros.ds_add(ds, 5) }}") finds the ds_add entry.
    """
    q = query.strip()
    # Strip {{ }} wrapper
    match = re.match(r"^\{\{\s*(.+?)\s*\}\}$", q)
    if match:
        q = match.group(1)
    # Strip macros. prefix
    if q.startswith("macros."):
        q = q[len("macros."):]
    # Strip var.value. prefix
    if q.startswith("var.value."):
        q = q[len("var.value."):]
    return q
```

In `lookup()`, normalize the query before the exact match chain:
```python
def lookup(concept: str, knowledge: dict[str, Any]) -> dict[str, Any]:
    concept = normalize_query(concept)
    # ... rest of existing logic
```

**Part B: Add schedule_interval to scaffold_project**

Modify `scaffold_project()` to accept a new parameter:
```python
async def scaffold_project(
    output_directory: str,
    project_name: str | None = None,
    include_docker: bool = True,
    include_github_actions: bool = True,
    schedule_interval: str | None = None,  # NEW
) -> str:
```

Note: Use `str | None` not `str | timedelta | None` — the MCP tool receives strings from the LLM. The LLM passes a cron string, a number of seconds (as string for timedelta), or None.

Add a helper function `_schedule_yaml(schedule_interval: str | None) -> str`:
- If `schedule_interval` is None or empty string: return `""` (omit entirely per CONTEXT.md: "No schedule: omit schedule section from prefect.yaml entirely — no comments, no placeholders")
- If `schedule_interval` is `"@once"`: return `""` (omit entirely)
- If `schedule_interval` is a cron string (contains spaces or starts with `@`): return `    schedules:\n      - cron: "{schedule_interval}"\n` — handle `@daily`→`"0 0 * * *"`, `@hourly`→`"0 * * * *"`, `@weekly`→`"0 0 * * 0"`, `@monthly`→`"0 0 1 * *"`, `@yearly`→`"0 0 1 1 *"` preset conversions
- If `schedule_interval` is a string of digits (seconds): return `    schedules:\n      - interval: {schedule_interval}\n`

Modify `_write_prefect_yaml()` to accept `schedule_interval` and inject real schedule config into the deployments section. Change the commented-out example deployment to a real deployment entry when schedule_interval is provided:

```yaml
deployments:
  - name: {project_name}
    entrypoint: deployments/default/{project_name}/flow.py:{project_name}
    schedules:
      - cron: "0 6 * * *"
    work_pool: *default_pool
```

When schedule_interval is None, keep the current commented-out example format.

Pass `schedule_interval` through: `scaffold_project` → `_write_prefect_yaml`.

Update the report JSON to include `"schedule": schedule_interval` in the result.

**Part C: Add schedule tests to test_scaffold.py**

Add a new test class `TestScheduleTranslation` with these tests:

1. `test_scaffold_with_cron_schedule`: Call `scaffold_project(schedule_interval="0 6 * * *")`, verify prefect.yaml contains `cron: "0 6 * * *"` under deployments
2. `test_scaffold_with_interval_schedule`: Call `scaffold_project(schedule_interval="3600")`, verify prefect.yaml contains `interval: 3600`
3. `test_scaffold_with_no_schedule`: Call `scaffold_project(schedule_interval=None)`, verify prefect.yaml does NOT have a real schedules entry under a deployment (commented-out examples are fine)
4. `test_scaffold_with_once_schedule`: Call `scaffold_project(schedule_interval="@once")`, verify schedules section is omitted
5. `test_scaffold_with_preset_daily`: Call `scaffold_project(schedule_interval="@daily")`, verify prefect.yaml contains `cron: "0 0 * * *"`

Also add a test for query normalization in test_knowledge.py:
6. `test_normalize_jinja_wrapper`: `normalize_query("{{ macros.ds_add(ds, 5) }}")` returns `"ds_add(ds, 5)"`
7. `test_normalize_var_value`: `normalize_query("var.value.my_key")` returns `"my_key"`
8. `test_normalize_plain`: `normalize_query("PythonOperator")` returns `"PythonOperator"` (no change)

Import `normalize_query` from `airflow_unfactor.knowledge` in test_knowledge.py.
  </action>
  <verify>
    <automated>cd /Users/gcoyne/src/prefect/airflow-unfactor && uv run pytest tests/test_scaffold.py tests/test_knowledge.py -x -q 2>&1 | tail -5</automated>
  </verify>
  <done>knowledge.py has normalize_query() called in lookup(); scaffold.py accepts schedule_interval and generates real schedule YAML; all scaffold and knowledge tests pass including new schedule and normalization tests</done>
</task>

</tasks>

<verification>
- `lookup("{{ macros.ds_add(ds, 5) }}", knowledge)` does not return `not_found` (query normalization strips Jinja syntax)
- `lookup("depends_on_past", knowledge)` returns entry with workaround code pattern (after Colin compilation)
- `scaffold_project(schedule_interval="0 6 * * *")` generates `cron: "0 6 * * *"` in prefect.yaml deployments section
- `scaffold_project(schedule_interval=None)` omits schedules section entirely
- All existing tests still pass (no regressions)
</verification>

<success_criteria>
1. patterns.md has `jinja-template-variables` section covering 10+ macros with intent-first explanations
2. concepts.md has `depends-on-past` and `deferrable-operators` entries with `equivalent: none` + workaround
3. knowledge.py `normalize_query()` strips `{{ }}`, `macros.`, and `var.value.` prefixes
4. scaffold.py accepts `schedule_interval` parameter and generates correct schedule YAML
5. All new and existing tests pass: `uv run pytest -x -q`
</success_criteria>

<output>
After completion, create `.planning/phases/03-p2-knowledge-expansion/03-02-SUMMARY.md`
</output>
